diff --git a/CMakeLists.txt b/CMakeLists.txt
index 93000f71..3d2a7665 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -73,7 +73,7 @@ option ( BUILD_SHARED_LIBS "Build a shared object or DLL" on )
 option ( enable-dbus "compile DBUS support (if it is available)" on )
 option ( enable-ipv6  "enable ipv6 support" on )
 option ( enable-jack "compile JACK support (if it is available)" on )
-option ( enable-ladspa "enable LADSPA effect units" on )
+option ( enable-ladspa "enable LADSPA effect units" off )
 option ( enable-libinstpatch "use libinstpatch (if available) to load DLS and GIG files" on )
 option ( enable-libsndfile "compile libsndfile support (if it is available)" on )
 option ( enable-midishare "compile MidiShare support (if it is available)" on )
@@ -86,7 +86,7 @@ option ( enable-wasapi "compile Windows WASAPI support (if it is available)" on
 option ( enable-waveout "compile Windows WaveOut support (if it is available)" on )
 option ( enable-winmidi "compile Windows MIDI support (if it is available)" on )
 option ( enable-sdl2 "compile SDL2 audio support (if it is available)" on )
-option ( enable-pkgconfig "use pkg-config to locate fluidsynth's (mostly optional) dependencies" on )
+option ( enable-pkgconfig "use pkg-config to locate fluidsynth's (mostly optional) dependencies" off )
 option ( enable-pulseaudio "compile PulseAudio support (if it is available)" on )
 option ( enable-readline "compile readline lib line editing (if it is available)" on )
 option ( enable-threads "enable multi-threading support (such as parallel voice synthesis)" on )
@@ -131,7 +131,7 @@ mark_as_advanced ( LIB_SUFFIX )
 set(CMAKE_C_STANDARD 90)
 
 # the default C++ standard to use for all targets
-set(CMAKE_CXX_STANDARD 98)
+set(CMAKE_CXX_STANDARD 11)
 
 # whether to use gnu extensions
 set(CMAKE_CXX_EXTENSIONS OFF)
@@ -184,6 +184,7 @@ check_include_file ( pthread.h HAVE_PTHREAD_H )
 check_include_file ( signal.h HAVE_SIGNAL_H )
 check_include_file ( getopt.h HAVE_GETOPT_H )
 check_include_file ( stdint.h HAVE_STDINT_H )
+check_include_file ( stdatomic.h HAVE_STDATOMIC_H )
 check_type_size ( "long long" LONG_LONG )
 if ( NOT HAVE_LONG_LONG AND NOT MSVC)
     message ( FATAL_ERROR "Your compiler does not support intrinsic type 'long long'. Unable to compile fluidsynth." )
@@ -492,38 +493,9 @@ if ( ASTYLE )
     )
 endif(ASTYLE)
 
-if(NOT enable-pkgconfig)
-
-    FIND_LIBRARY( GLIB_LIB NAMES glib glib-2.0 PATH GLIB_LIBRARY_DIR )
-    FIND_LIBRARY( GTHREAD_LIB NAMES gthread gthread-2.0 PATH GTHREAD_LIBRARY_DIR )
-    FIND_PATH( GLIBH_DIR glib.h PATH GLIB_INCLUDE_DIR )
-    FIND_PATH( GLIBCONF_DIR glibconfig.h PATH GLIBCONF_INCLUDE_DIR )
-
-    IF( GLIB_LIB MATCHES "GLIB_LIB-NOTFOUND" OR
-            GTHREAD_LIB MATCHES "GTHREAD_LIB-NOTFOUND" OR
-            GLIBH_DIR MATCHES "GLIBH_DIR-NOTFOUND" OR
-            GLIBCONF_DIR MATCHES "GLIBCONF_DIR-NOTFOUND")
-            message( WARNING "Not sure if I found GLIB, continuing anyway.")
-    ENDIF()
-
-    SET( GLIB_INCLUDE_DIRS ${GLIBH_DIR} ${GLIBCONF_DIR} )
-    SET( GLIB_LIBRARIES ${GLIB_LIB} ${GTHREAD_LIB} )
-
-    message( STATUS "GLIB_INCLUDE_DIRS: " ${GLIB_INCLUDE_DIRS} )
-    message( STATUS "GLIB_LIBRARIES: " ${GLIB_LIBRARIES} )
-
-else(NOT enable-pkgconfig)
+if(enable-pkgconfig)
 
     find_package ( PkgConfig REQUIRED )
-
-    # Mandatory libraries: glib and gthread
-    pkg_check_modules ( GLIB REQUIRED glib-2.0>=2.6.5 gthread-2.0>=2.6.5 )
-    list( APPEND PC_REQUIRES_PRIV "glib-2.0" "gthread-2.0")
-
-    if ( GLIB_glib-2.0_VERSION AND GLIB_glib-2.0_VERSION VERSION_LESS "2.26.0" )
-        message ( WARNING "Your version of glib is very old. This may cause problems with fluidsynth's sample cache on Windows. Consider updating to glib 2.26 or newer!" )
-    endif ( GLIB_glib-2.0_VERSION AND GLIB_glib-2.0_VERSION VERSION_LESS "2.26.0" )
-
     include ( UnsetPkgConfig )
 
     # Optional features
@@ -687,7 +659,7 @@ else(NOT enable-pkgconfig)
     endif ( READLINE_FOUND )
     endif ( enable-readline )
 
-endif(NOT enable-pkgconfig)
+endif(enable-pkgconfig)
 
 unset ( AUFILE_SUPPORT CACHE )
 if ( enable-aufile )
@@ -827,7 +799,6 @@ configure_file ( ${CMAKE_SOURCE_DIR}/src/config.cmake
 
 # Setup linker directories NOW, as the command will apply only to targets created after it has been called.
 link_directories (
-    ${GLIB_LIBRARY_DIRS}
     ${LASH_LIBRARY_DIRS}
     ${JACK_LIBRARY_DIRS}
     ${ALSA_LIBRARY_DIRS}
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 2803ca88..804d18de 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -35,7 +35,6 @@ include_directories (
 
 include_directories (
     SYSTEM
-    ${GLIB_INCLUDE_DIRS}
     ${PTHREADS_INCLUDE_DIR}
     ${SDL2_INCLUDE_DIR}
     ${LIBINSTPATCH_INCLUDE_DIRS}
@@ -162,6 +161,10 @@ set ( libfluidsynth_SOURCES
     utils/fluidsynth_priv.h
     utils/fluid_sys.c
     utils/fluid_sys.h
+    utils/fluid_threading.cpp
+    utils/fluid_threading.h
+    utils/fluid_atomics.c
+    utils/fluid_atomics.h
     sfloader/fluid_defsfont.c
     sfloader/fluid_defsfont.h
     sfloader/fluid_sfont.h
diff --git a/src/bindings/fluid_cmd.c b/src/bindings/fluid_cmd.c
index 1d4baaed..9295b77d 100644
--- a/src/bindings/fluid_cmd.c
+++ b/src/bindings/fluid_cmd.c
@@ -433,24 +433,7 @@ static const fluid_cmd_t fluid_commands[] =
 int
 fluid_command(fluid_cmd_handler_t *handler, const char *cmd, fluid_ostream_t out)
 {
-    int result, num_tokens = 0;
-    char **tokens = NULL;
-
-    if(cmd[0] == '#' || cmd[0] == '\0')
-    {
-        return 1;
-    }
-
-    if(!g_shell_parse_argv(cmd, &num_tokens, &tokens, NULL))
-    {
-        fluid_ostream_printf(out, "Error parsing command\n");
-        return FLUID_FAILED;
-    }
-
-    result = fluid_cmd_handler_handle(handler, num_tokens, &tokens[0], out);
-    g_strfreev(tokens);
-
-    return result;
+    return -1;
 }
 
 /**
diff --git a/src/config.cmake b/src/config.cmake
index d3aaf701..ba6e6b3d 100644
--- a/src/config.cmake
+++ b/src/config.cmake
@@ -124,6 +124,9 @@
 /* Define to 1 if you have the <getopt.h> header file. */
 #cmakedefine HAVE_GETOPT_H @HAVE_GETOPT_H@
 
+/* Define to 1 if you have the <stdatomic.h> header file. */
+#cmakedefine HAVE_STDATOMIC_H @HAVE_STDATOMIC_H@
+
 /* Define to 1 if you have the inet_ntop() function. */
 #cmakedefine HAVE_INETNTOP @HAVE_INETNTOP@
 
diff --git a/src/drivers/fluid_oss.c b/src/drivers/fluid_oss.c
index 9f27735d..ed82d8fc 100644
--- a/src/drivers/fluid_oss.c
+++ b/src/drivers/fluid_oss.c
@@ -562,7 +562,7 @@ fluid_oss_audio_run(void *d)
         if(write(dev->dspfd, buffer, dev->buffer_byte_size) < 0)
         {
             FLUID_LOG(FLUID_ERR, "Error writing to OSS sound device: %s",
-                      g_strerror(errno));
+                      strerror(errno));
             break;
         }
     }
@@ -602,7 +602,7 @@ fluid_oss_audio_run2(void *d)
         if(write(dev->dspfd, buffer, dev->buffer_byte_size) < 0)
         {
             FLUID_LOG(FLUID_ERR, "Error writing to OSS sound device: %s",
-                      g_strerror(errno));
+                      strerror(errno));
             break;
         }
     }
diff --git a/src/drivers/fluid_pulse.c b/src/drivers/fluid_pulse.c
index f7a74dea..d30c2994 100644
--- a/src/drivers/fluid_pulse.c
+++ b/src/drivers/fluid_pulse.c
@@ -115,7 +115,7 @@ new_fluid_pulse_audio_driver2(fluid_settings_t *settings,
     {
         if(FLUID_STRCMP(media_role, "") != 0)
         {
-            g_setenv("PULSE_PROP_media.role", media_role, TRUE);
+            setenv("PULSE_PROP_media.role", media_role, TRUE);
         }
 
         FLUID_FREE(media_role);       /* -- free media_role string */
diff --git a/src/fluidsynth.c b/src/fluidsynth.c
index 55d1000f..28a1850f 100644
--- a/src/fluidsynth.c
+++ b/src/fluidsynth.c
@@ -894,12 +894,6 @@ int main(int argc, char **argv)
         {
             config_file = fluid_get_sysconf(buf, sizeof(buf));
         }
-
-        /* if the automatically selected command file does not exist, do not even attempt to open it */
-        if(!g_file_test(config_file, G_FILE_TEST_EXISTS))
-        {
-            config_file = NULL;
-        }
     }
 
     /* Handle set commands before creating the synth */
diff --git a/src/midi/fluid_midi.c b/src/midi/fluid_midi.c
index cab651b8..2ef0d709 100644
--- a/src/midi/fluid_midi.c
+++ b/src/midi/fluid_midi.c
@@ -2191,7 +2191,8 @@ fluid_player_callback(void *data, unsigned int msec)
     while(loadnextfile);
 
     /* do not update the status if the player has been stopped already */
-    fluid_atomic_int_compare_and_exchange(&player->status, FLUID_PLAYER_PLAYING, status);
+    int s = FLUID_PLAYER_PLAYING;
+    fluid_atomic_int_compare_and_exchange(&player->status, &s, status);
 
     return 1;
 }
@@ -2283,7 +2284,8 @@ int fluid_player_seek(fluid_player_t *player, int ticks)
 
     if(fluid_player_get_status(player) == FLUID_PLAYER_PLAYING)
     {
-        if(fluid_atomic_int_compare_and_exchange(&player->seek_ticks, -1, ticks))
+        int val = -1;
+        if(fluid_atomic_int_compare_and_exchange(&player->seek_ticks, &val, ticks))
         {
             // new seek position has been set, as no previous seek was in progress
             return FLUID_OK;
diff --git a/src/synth/fluid_synth.c b/src/synth/fluid_synth.c
index b6a8c3ee..81273b06 100644
--- a/src/synth/fluid_synth.c
+++ b/src/synth/fluid_synth.c
@@ -631,7 +631,8 @@ new_fluid_synth(fluid_settings_t *settings)
     double sample_rate_min, sample_rate_max;
 
     /* initialize all the conversion tables and other stuff */
-    if(fluid_atomic_int_compare_and_exchange(&fluid_synth_initialized, 0, 1))
+    int val = 0;
+    if(fluid_atomic_int_compare_and_exchange(&fluid_synth_initialized, &val, 1))
     {
         fluid_synth_init();
     }
diff --git a/src/utils/fluid_atomics.c b/src/utils/fluid_atomics.c
new file mode 100644
index 00000000..7532e45e
--- /dev/null
+++ b/src/utils/fluid_atomics.c
@@ -0,0 +1,303 @@
+/**
+ * MSVC doesn't support C11 atomics (yet)
+ * This whole hack is hopefully provisional
+ */
+
+#ifdef _MSC_VER
+
+#include <stdio.h>
+#include "fluid_atomics.h"
+
+#ifdef _WIN32
+#pragma warning(disable : 4800)
+
+#include <intrin.h>
+
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+
+#ifndef _WIN64
+/* The following is needed for x86 */
+#define _InterlockedIncrement64 InterlockedIncrement64
+#define _InterlockedDecrement64 InterlockedDecrement64
+#define _InterlockedExchangeAdd64 InterlockedExchangeAdd64
+#define _InterlockedOr64 InterlockedOr64
+#define _InterlockedAnd64 InterlockedAnd64
+#define _InterlockedXor64 InterlockedXor64
+#define _InterlockedExchange64 InterlockedExchange64
+#endif
+#endif
+
+int8_t zenny_atomic_fetch_add8(volatile atomic_schar *object, int8_t operand)
+{
+    int8_t expected = *object;
+    int8_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected + operand;
+    } while ((success = zenny_atomic_compare_exchange8(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int16_t zenny_atomic_fetch_add16(volatile atomic_short *object, int16_t operand)
+{
+    int16_t expected = *object;
+    int16_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected + operand;
+    } while ((success = zenny_atomic_compare_exchange16(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int32_t zenny_atomic_fetch_add32(volatile atomic_long *object, int32_t operand)
+{
+    int32_t expected = *object;
+    int32_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected + operand;
+    } while ((success = zenny_atomic_compare_exchange32(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int64_t zenny_atomic_fetch_add64(volatile atomic_llong *object, int64_t operand)
+{
+    int64_t expected = *object;
+    int64_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected + operand;
+    } while ((success = zenny_atomic_compare_exchange64(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int8_t zenny_atomic_fetch_sub8(volatile atomic_schar *object, int8_t operand)
+{
+    int8_t expected = *object;
+    int8_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected - operand;
+    } while ((success = zenny_atomic_compare_exchange8(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int16_t zenny_atomic_fetch_sub16(volatile atomic_short *object, int16_t operand)
+{
+    int16_t expected = *object;
+    int16_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected - operand;
+    } while ((success = zenny_atomic_compare_exchange16(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int32_t zenny_atomic_fetch_sub32(volatile atomic_long *object, int32_t operand)
+{
+    int32_t expected = *object;
+    int32_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected - operand;
+    } while ((success = zenny_atomic_compare_exchange32(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int64_t zenny_atomic_fetch_sub64(volatile atomic_llong *object, int64_t operand)
+{
+    int64_t expected = *object;
+    int64_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected - operand;
+    } while ((success = zenny_atomic_compare_exchange64(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int8_t zenny_atomic_fetch_or8(volatile atomic_schar *object, int8_t operand)
+{
+    return _InterlockedOr8(object, operand);
+}
+
+int16_t zenny_atomic_fetch_or16(volatile atomic_short *object, int16_t operand)
+{
+    return _InterlockedOr16(object, operand);
+}
+
+int32_t zenny_atomic_fetch_or32(volatile atomic_long *object, int32_t operand)
+{
+    return _InterlockedOr(object, operand);
+}
+
+int64_t zenny_atomic_fetch_or64(volatile atomic_llong *object, int64_t operand)
+{
+    return _InterlockedOr64(object, operand);
+}
+
+int8_t zenny_atomic_fetch_xor8(volatile atomic_schar *object, int8_t operand)
+{
+    return _InterlockedXor8(object, operand);
+}
+
+int16_t zenny_atomic_fetch_xor16(volatile atomic_short *object, int16_t operand)
+{
+    return _InterlockedXor16(object, operand);
+}
+
+int32_t zenny_atomic_fetch_xor32(volatile atomic_long *object, int32_t operand)
+{
+    return _InterlockedXor(object, operand);
+}
+
+int64_t zenny_atomic_fetch_xor64(volatile atomic_llong *object, int64_t operand)
+{
+    return _InterlockedXor64(object, operand);
+}
+
+int8_t zenny_atomic_fetch_and8(volatile atomic_schar *object, int8_t operand)
+{
+    return _InterlockedAnd8(object, operand);
+}
+
+int16_t zenny_atomic_fetch_and16(volatile atomic_short *object, int16_t operand)
+{
+    return _InterlockedAnd16(object, operand);
+}
+
+int32_t zenny_atomic_fetch_and32(volatile atomic_long *object, int32_t operand)
+{
+    return _InterlockedAnd(object, operand);
+}
+
+int64_t zenny_atomic_fetch_and64(volatile atomic_llong *object, int64_t operand)
+{
+    return _InterlockedAnd64(object, operand);
+}
+
+int8_t zenny_atomic_exchange8(volatile atomic_schar *object, int8_t desired)
+{
+    return _InterlockedExchange8(object, desired);
+}
+
+int16_t zenny_atomic_exchange16(volatile atomic_short *object, int16_t desired)
+{
+    return _InterlockedExchange16(object, desired);
+}
+
+int32_t zenny_atomic_exchange32(volatile atomic_long *object, int32_t desired)
+{
+    return _InterlockedExchange(object, desired);
+}
+
+int64_t zenny_atomic_exchange64(volatile atomic_llong *object, int64_t desired)
+{
+    return _InterlockedExchange64(object, desired);
+}
+
+bool zenny_atomic_compare_exchange8(volatile atomic_schar *object, int8_t *expected, int8_t desired)
+{
+    int8_t comparand = *expected;
+    const int8_t dstValue = _InterlockedCompareExchange8(object, desired, comparand);
+    bool success = dstValue == comparand;
+    if (!success)
+        *expected = dstValue;
+
+    return success;
+}
+
+bool zenny_atomic_compare_exchange16(volatile atomic_short *object, int16_t *expected, int16_t desired)
+{
+    int16_t comparand = *expected;
+    const int16_t dstValue = _InterlockedCompareExchange16(object, desired, comparand);
+    bool success = dstValue == comparand;
+    if (!success)
+        *expected = dstValue;
+
+    return success;
+}
+
+bool zenny_atomic_compare_exchange32(volatile atomic_long *object, int32_t *expected, int32_t desired)
+{
+    int32_t comparand = *expected;
+    int32_t dstValue = _InterlockedCompareExchange(object, desired, comparand);
+    bool success = dstValue == comparand;
+    if (!success)
+        *expected = dstValue;
+
+    return success;
+}
+
+bool zenny_atomic_compare_exchange64(volatile atomic_llong *object, int64_t *expected, int64_t desired)
+{
+    int64_t comparand = *expected;
+    int64_t dstValue = _InterlockedCompareExchange64(object, desired, comparand);
+    bool success = dstValue == comparand;
+    if (!success)
+        *expected = dstValue;
+
+    return success;
+}
+
+bool atomic_flag_test_and_set(volatile atomic_flag *flag)
+{
+    return _InterlockedExchange8((volatile char *)flag, 1) == 1;
+}
+
+bool atomic_flag_test_and_set_explicit(volatile atomic_flag *object, memory_order order)
+{
+    return atomic_flag_test_and_set(object);
+}
+
+void atomic_flag_clear(volatile atomic_flag *flag)
+{
+    _InterlockedExchange8((volatile char *)flag, 0);
+}
+
+void atomic_flag_clear_explicit(volatile atomic_flag *object, memory_order order)
+{
+    atomic_flag_clear(object);
+}
+
+#endif
diff --git a/src/utils/fluid_atomics.h b/src/utils/fluid_atomics.h
new file mode 100644
index 00000000..f7d6aef0
--- /dev/null
+++ b/src/utils/fluid_atomics.h
@@ -0,0 +1,213 @@
+#ifndef _FLUID_ATOMICS_H
+#define _FLUID_ATOMICS_H
+
+/**
+ * Original code from https://github.com/zenny-chen/simple-stdatomic-for-VS-Clang
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(_MSC_VER)
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <uchar.h>
+
+#define ATOMIC_VAR_INIT(value) (value)
+#define atomic_init(object, value) (void)(*(object) = (value))
+
+#ifdef __GNUC__
+#define atomic_store(object, desired) (void)(*(volatile typeof(*(object)) *)(object) = (desired))
+#define atomic_load(object) *(volatile typeof(*(object)) *)(object)
+#else
+#define atomic_store(object, desired) (void)(*(object) = (desired))
+#define atomic_load(object) *(object)
+#endif
+
+#define ATOMIC_FLAG_INIT \
+    {                    \
+        0                \
+    }
+
+typedef enum memory_order
+{
+    memory_order_relaxed,
+    memory_order_consume,
+    memory_order_acquire,
+    memory_order_release,
+    memory_order_acq_rel,
+    memory_order_seq_cst
+} memory_order;
+
+#define atomic_load_explicit(object, order) atomic_load(object)
+#define atomic_store_explicit(object, desired, order) atomic_store((object), (desired))
+
+
+typedef struct atomic_flag
+{
+    bool _Value;
+} atomic_flag;
+
+typedef bool atomic_bool;
+typedef char atomic_char;
+typedef unsigned char atomic_uchar;
+typedef signed char atomic_schar;
+typedef short atomic_short;
+typedef unsigned short atomic_ushort;
+typedef int atomic_int;
+typedef unsigned atomic_uint;
+typedef long atomic_long;
+typedef unsigned long atomic_ulong;
+typedef long long atomic_llong;
+typedef unsigned long long atomic_ullong;
+typedef intptr_t atomic_intptr_t;
+typedef uintptr_t atomic_uintptr_t;
+typedef size_t atomic_size_t;
+typedef ptrdiff_t atomic_ptrdiff_t;
+typedef intmax_t atomic_intmax_t;
+typedef uintmax_t atomic_uintmax_t;
+typedef char16_t atomic_char16_t;
+typedef char32_t atomic_char32_t;
+typedef wchar_t atomic_wchar_t;
+
+
+extern bool atomic_flag_test_and_set(volatile atomic_flag *object);
+extern bool atomic_flag_test_and_set_explicit(volatile atomic_flag *object, memory_order order);
+
+extern void atomic_flag_clear(volatile atomic_flag *object);
+extern void atomic_flag_clear_explicit(volatile atomic_flag *object, memory_order order);
+
+
+#define atomic_fetch_add(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                         \
+     zenny_atomic_fetch_add8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                        \
+      zenny_atomic_fetch_add16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                       \
+       zenny_atomic_fetch_add32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_add64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_add_explicit(object, operand, order) atomic_fetch_add((object), (operand))
+
+extern int8_t zenny_atomic_fetch_add8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_add16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_add32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_add64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_fetch_sub(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                         \
+     zenny_atomic_fetch_sub8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                        \
+      zenny_atomic_fetch_sub16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                       \
+       zenny_atomic_fetch_sub32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_sub64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_sub_explicit(object, operand, order) atomic_fetch_sub((object), (operand))
+
+extern int8_t zenny_atomic_fetch_sub8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_sub16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_sub32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_sub64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_fetch_or(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                        \
+     zenny_atomic_fetch_or8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                       \
+      zenny_atomic_fetch_or16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                      \
+       zenny_atomic_fetch_or32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_or64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_or_explicit(object, operand, order) atomic_fetch_or((object), (operand))
+
+extern int8_t zenny_atomic_fetch_or8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_or16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_or32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_or64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_fetch_xor(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                         \
+     zenny_atomic_fetch_xor8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                        \
+      zenny_atomic_fetch_xor16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                       \
+       zenny_atomic_fetch_xor32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_xor64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_xor_explicit(object, operand, order) atomic_fetch_xor((object), (operand))
+
+extern int8_t zenny_atomic_fetch_xor8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_xor16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_xor32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_xor64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_fetch_and(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                         \
+     zenny_atomic_fetch_and8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                        \
+      zenny_atomic_fetch_and16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                       \
+       zenny_atomic_fetch_and32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_and64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_and_explicit(object, operand, order) atomic_fetch_and((object), (operand))
+
+extern int8_t zenny_atomic_fetch_and8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_and16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_and32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_and64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_exchange(object, desired)                                               \
+    ((sizeof(*(object)) == 1) ?                                                        \
+     zenny_atomic_exchange8((volatile atomic_schar *)(object), (int8_t)(desired)) :    \
+     ((sizeof(*(object)) == 2) ?                                                       \
+      zenny_atomic_exchange16((volatile atomic_short *)(object), (int16_t)(desired)) : \
+      ((sizeof(*(object)) == 4) ?                                                      \
+       zenny_atomic_exchange32((volatile atomic_long *)(object), (int32_t)(desired)) : \
+       zenny_atomic_exchange64((volatile atomic_llong *)(object), (int64_t)(desired)))))
+
+#define atomic_exchange_explicit(object, desired, order) atomic_exchange((object), (desired))
+
+extern int8_t zenny_atomic_exchange8(volatile atomic_schar *object, int8_t desired);
+extern int16_t zenny_atomic_exchange16(volatile atomic_short *object, int16_t desired);
+extern int32_t zenny_atomic_exchange32(volatile atomic_long *object, int32_t desired);
+extern int64_t zenny_atomic_exchange64(volatile atomic_llong *object, int64_t desired);
+
+
+#define atomic_compare_exchange_strong(object, expected, desired)                                                     \
+    (sizeof(*(object)) == 1 ?                                                                                         \
+     zenny_atomic_compare_exchange8((volatile atomic_schar *)(object), (int8_t *)(expected), (int8_t)(desired)) :     \
+     (sizeof(*(object)) == 2 ?                                                                                        \
+      zenny_atomic_compare_exchange16((volatile atomic_short *)(object), (int16_t *)(expected), (int16_t)(desired)) : \
+      (sizeof(*(object)) == 4 ?                                                                                       \
+       zenny_atomic_compare_exchange32((volatile atomic_long *)(object), (int32_t *)(expected), (int32_t)(desired)) : \
+       zenny_atomic_compare_exchange64((volatile atomic_llong *)(object), (int64_t *)(expected), (int64_t)(desired)))))
+
+#define atomic_compare_exchange_weak atomic_compare_exchange_strong
+
+#define atomic_compare_exchange_strong_explicit(object, expected, desired, success, failure) \
+    atomic_compare_exchange_strong((object), (expected), (desired))
+#define atomic_compare_exchange_weak_explicit(object, expected, desired, success, failure) \
+    atomic_compare_exchange_weak((object), (expected), (desired))
+
+extern bool zenny_atomic_compare_exchange8(volatile atomic_schar *object, int8_t *expected, int8_t desired);
+extern bool zenny_atomic_compare_exchange16(volatile atomic_short *object, int16_t *expected, int16_t desired);
+extern bool zenny_atomic_compare_exchange32(volatile atomic_long *object, int32_t *expected, int32_t desired);
+extern bool zenny_atomic_compare_exchange64(volatile atomic_llong *object, int64_t *expected, int64_t desired);
+
+#endif // #if defined(_MSC_VER)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/utils/fluid_sys.c b/src/utils/fluid_sys.c
index e3c0ea4d..e3d0bd3b 100644
--- a/src/utils/fluid_sys.c
+++ b/src/utils/fluid_sys.c
@@ -378,7 +378,7 @@ char *fluid_strtok(char **str, char *delim)
  */
 void fluid_msleep(unsigned int msecs)
 {
-    g_usleep(msecs * 1000);
+    _thread_sleep(msecs * 1000);
 }
 
 /**
@@ -413,16 +413,7 @@ fluid_utime(void)
 {
     double utime;
 
-#if GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 28
-    /* use high precision monotonic clock if available (g_monotonic_time().
-     * For Windows, if this clock is actually implemented as low prec. clock
-     * (i.e. in case glib is too old), high precision performance counter are
-     * used instead.
-     * see: https://bugzilla.gnome.org/show_bug.cgi?id=783340
-     */
-#if defined(WITH_PROFILING) &&  defined(WIN32) &&\
-	/* glib < 2.53.3 */\
-	(GLIB_MINOR_VERSION <= 53 && (GLIB_MINOR_VERSION < 53 || GLIB_MICRO_VERSION < 3))
+#ifdef WIN32
     /* use high precision performance counter. */
     static LARGE_INTEGER freq_cache = {0, 0};	/* Performance Frequency */
     LARGE_INTEGER perf_cpt;
@@ -435,13 +426,7 @@ fluid_utime(void)
     QueryPerformanceCounter(&perf_cpt); /* Counter value */
     utime = perf_cpt.QuadPart * 1000000.0 / freq_cache.QuadPart; /* time in micros */
 #else
-    utime = g_get_monotonic_time();
-#endif
-#else
-    /* fallback to less precise clock */
-    GTimeVal timeval;
-    g_get_current_time(&timeval);
-    utime = (timeval.tv_sec * 1000000.0 + timeval.tv_usec);
+    utime = _monotonic_time();
 #endif
 
     return utime;
@@ -995,25 +980,8 @@ void fluid_profile_start_stop(unsigned int end_ticks, short clear_data)
  *
  */
 
-#if OLD_GLIB_THREAD_API
-
-/* Rather than inline this one, we just declare it as a function, to prevent
- * GCC warning about inline failure. */
-fluid_cond_t *
-new_fluid_cond(void)
-{
-    if(!g_thread_supported())
-    {
-        g_thread_init(NULL);
-    }
-
-    return g_cond_new();
-}
-
-#endif
-
-static gpointer
-fluid_thread_high_prio(gpointer data)
+static void*
+fluid_thread_high_prio(void* data)
 {
     fluid_thread_info_t *info = data;
 
@@ -1037,23 +1005,10 @@ fluid_thread_high_prio(gpointer data)
 fluid_thread_t *
 new_fluid_thread(const char *name, fluid_thread_func_t func, void *data, int prio_level, int detach)
 {
-    GThread *thread;
+    _thread *thread;
     fluid_thread_info_t *info = NULL;
-    GError *err = NULL;
 
-    g_return_val_if_fail(func != NULL, NULL);
-
-#if OLD_GLIB_THREAD_API
-
-    /* Make sure g_thread_init has been called.
-     * Probably not a good idea in a shared library,
-     * but what can we do *and* remain backwards compatible? */
-    if(!g_thread_supported())
-    {
-        g_thread_init(NULL);
-    }
-
-#endif
+    fluid_return_val_if_fail(func != NULL, NULL);
 
     if(prio_level > 0)
     {
@@ -1068,40 +1023,25 @@ new_fluid_thread(const char *name, fluid_thread_func_t func, void *data, int pri
         info->func = func;
         info->data = data;
         info->prio_level = prio_level;
-#if NEW_GLIB_THREAD_API
-        thread = g_thread_try_new(name, fluid_thread_high_prio, info, &err);
-#else
-        thread = g_thread_create(fluid_thread_high_prio, info, detach == FALSE, &err);
-#endif
+        _thread_create(thread, fluid_thread_high_prio, info);
     }
 
     else
     {
-#if NEW_GLIB_THREAD_API
-        thread = g_thread_try_new(name, (GThreadFunc)func, data, &err);
-#else
-        thread = g_thread_create((GThreadFunc)func, data, detach == FALSE, &err);
-#endif
+        _thread_create(thread, func, data);
     }
 
     if(!thread)
     {
-        FLUID_LOG(FLUID_ERR, "Failed to create the thread: %s",
-                  fluid_gerror_message(err));
-        g_clear_error(&err);
         FLUID_FREE(info);
         return NULL;
     }
 
-#if NEW_GLIB_THREAD_API
-
     if(detach)
     {
-        g_thread_unref(thread);    // Release thread reference, if caller wants to detach
+        _thread_detach(thread);
     }
 
-#endif
-
     return thread;
 }
 
@@ -1112,7 +1052,8 @@ new_fluid_thread(const char *name, fluid_thread_func_t func, void *data, int pri
 void
 delete_fluid_thread(fluid_thread_t *thread)
 {
-    /* Threads free themselves when they quit, nothing to do */
+    _thread_detach(thread);
+    free(thread);
 }
 
 /**
@@ -1123,7 +1064,7 @@ delete_fluid_thread(fluid_thread_t *thread)
 int
 fluid_thread_join(fluid_thread_t *thread)
 {
-    g_thread_join(thread);
+    _thread_join(thread);
 
     return FLUID_OK;
 }
@@ -1730,14 +1671,13 @@ FILE* fluid_file_open(const char* path, const char** errMsg)
     
     FILE* handle = NULL;
     
-    if(!g_file_test(path, G_FILE_TEST_EXISTS))
+    fluid_stat_buf_t statbuf;
+    int ret = fluid_stat(path, &statbuf);
+    if (ret != 0)
     {
-        if(errMsg != NULL)
-        {
-            *errMsg = ErrExist;
-        }
+        *errMsg = ErrExist;
     }
-    else if(!g_file_test(path, G_FILE_TEST_IS_REGULAR))
+    else if ((statbuf.st_mode & S_IFMT) != S_IFREG)
     {
         if(errMsg != NULL)
         {
diff --git a/src/utils/fluid_sys.h b/src/utils/fluid_sys.h
index 635bcf6d..f65e2407 100644
--- a/src/utils/fluid_sys.h
+++ b/src/utils/fluid_sys.h
@@ -115,20 +115,20 @@
 
 #else
 
-/* Assume GLIB types */
-typedef gint8    int8_t;
-typedef guint8   uint8_t;
-typedef gint16   int16_t;
-typedef guint16  uint16_t;
-typedef gint32   int32_t;
-typedef guint32  uint32_t;
-typedef gint64   int64_t;
-typedef guint64  uint64_t;
-typedef guintptr uintptr_t;
-typedef gintptr  intptr_t;
+#error "Standard types are required at this time"
 
 #endif
 
+/* __STDC_NO_ATOMICS__ would be the standard way to check for this but MSVC doesn't have it */
+#if !HAVE_STDATOMIC_H
+#include "fluid_atomics.h"
+#else
+#include <stdatomic.h>
+#endif
+
+#include "fluid_threading.h"
+
+
 #if defined(WIN32) &&  HAVE_WINDOWS_H
 #include <winsock2.h>
 #include <ws2tcpip.h>	/* Provides also socklen_t */
@@ -154,10 +154,9 @@ typedef gintptr  intptr_t;
 #endif
 
 #ifdef LADSPA
-#include <gmodule.h>
+#error "No ladspa support, sorry"
 #endif
 
-#include <glib/gstdio.h>
 
 /**
  * Macro used for safely accessing a message from a GError and using a default
@@ -182,10 +181,18 @@ char* fluid_get_windows_error(void);
 #define FLUID_INT_TO_POINTER(x)   ((void *)(intptr_t)(x))
 
 /* Endian detection */
-#define FLUID_IS_BIG_ENDIAN       (G_BYTE_ORDER == G_BIG_ENDIAN)
+#ifdef __GNUC__
+#define FLUID_IS_BIG_ENDIAN (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#else
+#ifndef WORDS_BIGENDIAN
+#define FLUID_IS_BIG_ENDIAN 0
+#else
+#define FLUID_IS_BIG_ENDIAN WORDS_BIGENDIAN
+#endif
+#endif
 
-#define FLUID_LE32TOH(x)          GINT32_FROM_LE(x)
-#define FLUID_LE16TOH(x)          GINT16_FROM_LE(x)
+#define FLUID_LE32TOH(x)    ((int)(x))
+#define FLUID_LE16TOH(x)    ((short int)(x))
 
 #if FLUID_IS_BIG_ENDIAN
 #define FLUID_FOURCC(_a, _b, _c, _d) \
@@ -241,42 +248,36 @@ int fluid_timer_stop(fluid_timer_t *timer);
 int fluid_timer_is_running(const fluid_timer_t *timer);
 long fluid_timer_get_interval(const fluid_timer_t * timer);
 
-// Macros to use for pre-processor if statements to test which Glib thread API we have (pre or post 2.32)
-#define NEW_GLIB_THREAD_API   GLIB_CHECK_VERSION(2,32,0)
-#define OLD_GLIB_THREAD_API  !GLIB_CHECK_VERSION(2,32,0)
-
 /* Muteces */
 
-#if NEW_GLIB_THREAD_API
-
 /* glib 2.32 and newer */
 
 /* Regular mutex */
-typedef GMutex fluid_mutex_t;
+typedef _mutex fluid_mutex_t;
 #define FLUID_MUTEX_INIT          { 0 }
-#define fluid_mutex_init(_m)      g_mutex_init (&(_m))
-#define fluid_mutex_destroy(_m)   g_mutex_clear (&(_m))
-#define fluid_mutex_lock(_m)      g_mutex_lock(&(_m))
-#define fluid_mutex_unlock(_m)    g_mutex_unlock(&(_m))
+#define fluid_mutex_init(_m)      _mutex_init (&(_m))
+#define fluid_mutex_destroy(_m)   _mutex_clear (&(_m))
+#define fluid_mutex_lock(_m)      _mutex_lock(&(_m))
+#define fluid_mutex_unlock(_m)    _mutex_unlock(&(_m))
 
 /* Recursive lock capable mutex */
-typedef GRecMutex fluid_rec_mutex_t;
-#define fluid_rec_mutex_init(_m)      g_rec_mutex_init(&(_m))
-#define fluid_rec_mutex_destroy(_m)   g_rec_mutex_clear(&(_m))
-#define fluid_rec_mutex_lock(_m)      g_rec_mutex_lock(&(_m))
-#define fluid_rec_mutex_unlock(_m)    g_rec_mutex_unlock(&(_m))
+typedef _rec_mutex fluid_rec_mutex_t;
+#define fluid_rec_mutex_init(_m)      _rec_mutex_init(&(_m))
+#define fluid_rec_mutex_destroy(_m)   _rec_mutex_clear(&(_m))
+#define fluid_rec_mutex_lock(_m)      _rec_mutex_lock(&(_m))
+#define fluid_rec_mutex_unlock(_m)    _rec_mutex_unlock(&(_m))
 
 /* Dynamically allocated mutex suitable for fluid_cond_t use */
-typedef GMutex    fluid_cond_mutex_t;
-#define fluid_cond_mutex_lock(m)        g_mutex_lock(m)
-#define fluid_cond_mutex_unlock(m)      g_mutex_unlock(m)
+typedef _mutex    fluid_cond_mutex_t;
+#define fluid_cond_mutex_lock(m)        _mutex_lock(m)
+#define fluid_cond_mutex_unlock(m)      _mutex_unlock(m)
 
 static FLUID_INLINE fluid_cond_mutex_t *
 new_fluid_cond_mutex(void)
 {
-    GMutex *mutex;
-    mutex = g_new(GMutex, 1);
-    g_mutex_init(mutex);
+    _mutex *mutex;
+    mutex = FLUID_NEW(_mutex);
+    _mutex_init(mutex);
     return (mutex);
 }
 
@@ -284,22 +285,22 @@ static FLUID_INLINE void
 delete_fluid_cond_mutex(fluid_cond_mutex_t *m)
 {
     fluid_return_if_fail(m != NULL);
-    g_mutex_clear(m);
-    g_free(m);
+    _mutex_clear(m);
+    free(m);
 }
 
 /* Thread condition signaling */
-typedef GCond fluid_cond_t;
-#define fluid_cond_signal(cond)         g_cond_signal(cond)
-#define fluid_cond_broadcast(cond)      g_cond_broadcast(cond)
-#define fluid_cond_wait(cond, mutex)    g_cond_wait(cond, mutex)
+typedef _cond fluid_cond_t;
+#define fluid_cond_signal(cond)         _cond_signal(cond)
+#define fluid_cond_broadcast(cond)      _cond_broadcast(cond)
+#define fluid_cond_wait(cond, mutex)    _cond_wait(cond, mutex)
 
 static FLUID_INLINE fluid_cond_t *
 new_fluid_cond(void)
 {
-    GCond *cond;
-    cond = g_new(GCond, 1);
-    g_cond_init(cond);
+    _cond *cond;
+    cond = FLUID_NEW(_cond);
+    _cond_init(cond);
     return (cond);
 }
 
@@ -307,109 +308,36 @@ static FLUID_INLINE void
 delete_fluid_cond(fluid_cond_t *cond)
 {
     fluid_return_if_fail(cond != NULL);
-    g_cond_clear(cond);
-    g_free(cond);
+    _cond_clear(cond);
+    free(cond);
 }
 
 /* Thread private data */
 
-typedef GPrivate fluid_private_t;
+typedef _private fluid_private_t;
 #define fluid_private_init(_priv)                  memset (&_priv, 0, sizeof (_priv))
 #define fluid_private_free(_priv)
-#define fluid_private_get(_priv)                   g_private_get(&(_priv))
-#define fluid_private_set(_priv, _data)            g_private_set(&(_priv), _data)
-
-#else
-
-/* glib prior to 2.32 */
-
-/* Regular mutex */
-typedef GStaticMutex fluid_mutex_t;
-#define FLUID_MUTEX_INIT          G_STATIC_MUTEX_INIT
-#define fluid_mutex_destroy(_m)   g_static_mutex_free(&(_m))
-#define fluid_mutex_lock(_m)      g_static_mutex_lock(&(_m))
-#define fluid_mutex_unlock(_m)    g_static_mutex_unlock(&(_m))
-
-#define fluid_mutex_init(_m)      do { \
-  if (!g_thread_supported ()) g_thread_init (NULL); \
-  g_static_mutex_init (&(_m)); \
-} while(0)
-
-/* Recursive lock capable mutex */
-typedef GStaticRecMutex fluid_rec_mutex_t;
-#define fluid_rec_mutex_destroy(_m)   g_static_rec_mutex_free(&(_m))
-#define fluid_rec_mutex_lock(_m)      g_static_rec_mutex_lock(&(_m))
-#define fluid_rec_mutex_unlock(_m)    g_static_rec_mutex_unlock(&(_m))
-
-#define fluid_rec_mutex_init(_m)      do { \
-  if (!g_thread_supported ()) g_thread_init (NULL); \
-  g_static_rec_mutex_init (&(_m)); \
-} while(0)
-
-/* Dynamically allocated mutex suitable for fluid_cond_t use */
-typedef GMutex    fluid_cond_mutex_t;
-#define delete_fluid_cond_mutex(m)      g_mutex_free(m)
-#define fluid_cond_mutex_lock(m)        g_mutex_lock(m)
-#define fluid_cond_mutex_unlock(m)      g_mutex_unlock(m)
-
-static FLUID_INLINE fluid_cond_mutex_t *
-new_fluid_cond_mutex(void)
-{
-    if(!g_thread_supported())
-    {
-        g_thread_init(NULL);
-    }
-
-    return g_mutex_new();
-}
-
-/* Thread condition signaling */
-typedef GCond fluid_cond_t;
-fluid_cond_t *new_fluid_cond(void);
-#define delete_fluid_cond(cond)         g_cond_free(cond)
-#define fluid_cond_signal(cond)         g_cond_signal(cond)
-#define fluid_cond_broadcast(cond)      g_cond_broadcast(cond)
-#define fluid_cond_wait(cond, mutex)    g_cond_wait(cond, mutex)
-
-/* Thread private data */
-typedef GStaticPrivate fluid_private_t;
-#define fluid_private_get(_priv)                   g_static_private_get(&(_priv))
-#define fluid_private_set(_priv, _data)            g_static_private_set(&(_priv), _data, NULL)
-#define fluid_private_free(_priv)                  g_static_private_free(&(_priv))
-
-#define fluid_private_init(_priv)                  do { \
-  if (!g_thread_supported ()) g_thread_init (NULL); \
-  g_static_private_init (&(_priv)); \
-} while(0)
-
-#endif
-
+#define fluid_private_get(_priv)                   _private_get(&(_priv))
+#define fluid_private_set(_priv, _data)            _private_set(&(_priv), _data)
 
 /* Atomic operations */
 
-#define fluid_atomic_int_inc(_pi) g_atomic_int_inc(_pi)
-#define fluid_atomic_int_get(_pi) g_atomic_int_get(_pi)
-#define fluid_atomic_int_set(_pi, _val) g_atomic_int_set(_pi, _val)
-#define fluid_atomic_int_dec_and_test(_pi) g_atomic_int_dec_and_test(_pi)
+#define fluid_atomic_int_inc(_pi) atomic_fetch_add(_pi, 1)
+#define fluid_atomic_int_get(_pi) atomic_load(_pi)
+#define fluid_atomic_int_set(_pi, _val)     atomic_store(_pi, _val)
+#define fluid_atomic_int_dec_and_test(_pi)      atomic_fetch_add(_pi, -1)
 #define fluid_atomic_int_compare_and_exchange(_pi, _old, _new) \
-  g_atomic_int_compare_and_exchange(_pi, _old, _new)
+  atomic_compare_exchange_weak(_pi, _old, _new)
 
-#if GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 30)
-#define fluid_atomic_int_exchange_and_add(_pi, _add) \
-  g_atomic_int_add(_pi, _add)
-#define fluid_atomic_int_add(_pi, _add) \
-  g_atomic_int_add(_pi, _add)
-#else
 #define fluid_atomic_int_exchange_and_add(_pi, _add) \
-  g_atomic_int_exchange_and_add(_pi, _add)
+  atomic_fetch_add(_pi, _add)
 #define fluid_atomic_int_add(_pi, _add) \
-  g_atomic_int_exchange_and_add(_pi, _add)
-#endif
+  atomic_fetch_add(_pi, _add)
 
-#define fluid_atomic_pointer_get(_pp)           g_atomic_pointer_get(_pp)
-#define fluid_atomic_pointer_set(_pp, val)      g_atomic_pointer_set(_pp, val)
+#define fluid_atomic_pointer_get(_pp)           (void *)atomic_load(_pp)
+#define fluid_atomic_pointer_set(_pp, val)      atomic_store(_pp, val)
 #define fluid_atomic_pointer_compare_and_exchange(_pp, _old, _new) \
-  g_atomic_pointer_compare_and_exchange(_pp, _old, _new)
+  atomic_compare_exchange_weak(_pp, _old, _new)
 
 static FLUID_INLINE void
 fluid_atomic_float_set(fluid_atomic_float_t *fptr, float val)
@@ -437,12 +365,12 @@ typedef void *fluid_thread_return_t;
 /* static return value for thread functions which requires a return value */
 #define FLUID_THREAD_RETURN_VALUE (NULL)
 
-typedef GThread fluid_thread_t;
+typedef _thread fluid_thread_t;
 typedef fluid_thread_return_t (*fluid_thread_func_t)(void *data);
 
 #define FLUID_THREAD_ID_NULL            NULL                    /* A NULL "ID" value */
-#define fluid_thread_id_t               GThread *               /* Data type for a thread ID */
-#define fluid_thread_get_id()           g_thread_self()         /* Get unique "ID" for current thread */
+#define fluid_thread_id_t               _thread *               /* Data type for a thread ID */
+#define fluid_thread_get_id()           _thread_get_id() /* Get unique "ID" for current thread */
 
 fluid_thread_t *new_fluid_thread(const char *name, fluid_thread_func_t func, void *data,
                                  int prio_level, int detach);
@@ -487,23 +415,16 @@ fluid_istream_t fluid_socket_get_istream(fluid_socket_t sock);
 fluid_ostream_t fluid_socket_get_ostream(fluid_socket_t sock);
 
 /* File access */
-#define fluid_stat(_filename, _statbuf)   g_stat((_filename), (_statbuf))
-#if !GLIB_CHECK_VERSION(2, 26, 0)
-    /* GStatBuf has not been introduced yet, manually typedef to what they had at that time:
-     * https://github.com/GNOME/glib/blob/e7763678b56e3be073cc55d707a6e92fc2055ee0/glib/gstdio.h#L98-L115
-     */
-    #if defined(WIN32) || HAVE_WINDOWS_H // somehow reliably mock G_OS_WIN32??
-        // Any effort from our side to reliably mock GStatBuf on Windows is in vain. E.g. glib-2.16 is broken as it uses struct stat rather than struct _stat32 on Win x86.
-        // Disable it (the user has been warned by cmake).
-        #undef fluid_stat
-        #define fluid_stat(_filename, _statbuf)  (-1)
-        typedef struct _fluid_stat_buf_t{int st_mtime;} fluid_stat_buf_t;
-    #else
-        /* posix, OS/2, etc. */
-        typedef struct stat fluid_stat_buf_t;
-    #endif
+#if defined(__GNUC__) && defined(_WIN64)
+#define fluid_stat(_filename, _statbuf) _stat64i32((_filename), (_statbuf))
+#else
+#define fluid_stat(_filename, _statbuf) stat((_filename), (_statbuf))
+#endif
+#if defined(WIN32) || HAVE_WINDOWS_H
+        typedef struct _stat64i32 fluid_stat_buf_t;
 #else
-typedef GStatBuf fluid_stat_buf_t;
+/* posix, OS/2, etc. */
+typedef struct stat fluid_stat_buf_t;
 #endif
 
 FILE* fluid_file_open(const char* filename, const char** errMsg);
diff --git a/src/utils/fluid_threading.cpp b/src/utils/fluid_threading.cpp
new file mode 100644
index 00000000..82104de9
--- /dev/null
+++ b/src/utils/fluid_threading.cpp
@@ -0,0 +1,157 @@
+#include <cstdio>
+#include <functional>
+#include <chrono>
+#include <thread>
+#include <mutex>
+#include <atomic>
+#include <ratio>
+#include <condition_variable>
+
+#include "fluid_threading.h"
+
+thread_local void *privs[16];
+bool occupied[16] = { false };
+
+void _mutex_init(_mutex *mutex)
+{
+    mutex->mutex = (void *)(new std::mutex);
+}
+
+void _mutex_clear(_mutex *mutex)
+{
+    delete (std::mutex *)(mutex->mutex);
+    mutex->mutex = NULL;
+}
+
+void _mutex_lock(_mutex *mutex)
+{
+    if (!mutex->mutex)
+        mutex->mutex = (void *)(new std::mutex);
+    ((std::mutex *)(mutex->mutex))->lock();
+}
+
+void _mutex_unlock(_mutex *mutex)
+{
+    if (!mutex->mutex)
+        mutex->mutex = (void *)(new std::mutex);
+    ((std::mutex *)(mutex->mutex))->unlock();
+}
+
+void _rec_mutex_init(_rec_mutex *recmutex)
+{
+    recmutex->recmutex = (void *)(new std::recursive_mutex);
+}
+
+void _rec_mutex_clear(_rec_mutex *recmutex)
+{
+    delete (std::recursive_mutex *)(recmutex->recmutex);
+    recmutex->recmutex = NULL;
+}
+
+void _rec_mutex_lock(_rec_mutex *recmutex)
+{
+    if (!recmutex->recmutex)
+        recmutex->recmutex = (void *)(new std::recursive_mutex);
+    ((std::recursive_mutex *)(recmutex->recmutex))->lock();
+}
+
+void _rec_mutex_unlock(_rec_mutex *recmutex)
+{
+    if (!recmutex->recmutex)
+        recmutex->recmutex = (void *)(new std::recursive_mutex);
+    ((std::recursive_mutex *)(recmutex->recmutex))->unlock();
+}
+
+void _cond_init(_cond *cond)
+{
+    cond->cond = (void *)(new std::condition_variable_any);
+}
+
+void _cond_clear(_cond *cond)
+{
+    delete (std::condition_variable_any *)(cond->cond);
+}
+
+void _cond_signal(_cond *cond)
+{
+    ((std::condition_variable_any *)(cond->cond))->notify_one();
+}
+
+void _cond_broadcast(_cond *cond)
+{
+    ((std::condition_variable_any *)(cond->cond))->notify_all();
+}
+
+void _cond_wait(_cond *cond, _mutex *mutex)
+{
+    ((std::condition_variable_any *)(cond->cond))->wait(*(std::mutex *)(mutex->mutex));
+}
+
+void *_private_get(_private *priv)
+{
+    if (!priv->id)
+        for (int i = 0; i < 16; ++i)
+            if (!occupied[i])
+            {
+                priv->id = i + 1;
+                break;
+            }
+    if (priv->id)
+        return privs[priv->id - 1];
+    else
+        return NULL;
+}
+
+void _private_set(_private *priv, void *val)
+{
+    if (!priv->id)
+        for (int i = 0; i < 16; ++i)
+            if (!occupied[i])
+            {
+                priv->id = i + 1;
+                break;
+            }
+    if (priv->id)
+        privs[priv->id - 1] = val;
+}
+
+unsigned _thread_get_id(void)
+{
+    std::hash<std::thread::id> h;
+    return h(std::this_thread::get_id());
+}
+
+void _thread_create(_thread *th, _thread_func_t func, void *data)
+{
+    th->thrd = (void *)(new std::thread(func, data));
+}
+
+void _thread_detach(_thread *th)
+{
+    if (!th->thrd)
+        return;
+    ((std::thread *)(th->thrd))->detach();
+    delete (std::thread *)(th->thrd);
+    th->thrd = nullptr;
+}
+
+void _thread_join(_thread *th)
+{
+    if (!th->thrd)
+        return;
+    ((std::thread *)(th->thrd))->join();
+    delete (std::thread *)(th->thrd);
+    th->thrd = nullptr;
+}
+
+void _thread_sleep(unsigned long us)
+{
+    std::this_thread::sleep_for(std::chrono::microseconds(us));
+}
+
+double _monotonic_time()
+{
+    return std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(
+           std::chrono::steady_clock::now().time_since_epoch())
+    .count();
+}
diff --git a/src/utils/fluid_threading.h b/src/utils/fluid_threading.h
new file mode 100644
index 00000000..5ff498e7
--- /dev/null
+++ b/src/utils/fluid_threading.h
@@ -0,0 +1,65 @@
+#ifndef _FLUID_THREADING_H
+#define _FLUID_THREADING_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void* (*_thread_func_t)(void *data);
+
+typedef struct __mtx
+{
+    void *mutex;
+} _mutex;
+
+typedef struct __recmtx
+{
+    void *recmutex;
+} _rec_mutex;
+
+typedef struct __cnd
+{
+    void *cond;
+} _cond;
+
+typedef struct __prvt
+{
+    int id;
+} _private;
+
+typedef struct __thrd
+{
+    void *thrd;
+} _thread;
+
+void _mutex_init(_mutex *mutex);
+void _mutex_clear(_mutex *mutex);
+void _mutex_lock(_mutex *mutex);
+void _mutex_unlock(_mutex *mutex);
+
+void _rec_mutex_init(_rec_mutex *recmutex);
+void _rec_mutex_clear(_rec_mutex *recmutex);
+void _rec_mutex_lock(_rec_mutex *recmutex);
+void _rec_mutex_unlock(_rec_mutex *recmutex);
+
+void _cond_init(_cond *cond);
+void _cond_clear(_cond *cond);
+void _cond_signal(_cond *cond);
+void _cond_broadcast(_cond *cond);
+void _cond_wait(_cond *cond, _mutex *mutex);
+
+void *_private_get(_private *priv);
+void _private_set(_private *priv, void *val);
+
+unsigned _thread_get_id(void);
+void _thread_create(_thread *th, _thread_func_t func, void *data);
+void _thread_detach(_thread *th);
+void _thread_join(_thread *th);
+void _thread_sleep(unsigned long us);
+double _monotonic_time(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/utils/fluidsynth_priv.h b/src/utils/fluidsynth_priv.h
index f8f36381..83a0a951 100644
--- a/src/utils/fluidsynth_priv.h
+++ b/src/utils/fluidsynth_priv.h
@@ -29,8 +29,6 @@
 #ifndef _FLUIDSYNTH_PRIV_H
 #define _FLUIDSYNTH_PRIV_H
 
-#include <glib.h>
-
 #include "config.h"
 
 #if HAVE_STDLIB_H
@@ -45,6 +43,11 @@
 #include <string.h>
 #endif
 
+#ifdef _MSC_VER
+#include <malloc.h>
+#endif
+
+#include "fluid_threading.h"
 
 #include "fluidsynth.h"
 
@@ -60,12 +63,20 @@ typedef float fluid_real_t;
 typedef double fluid_real_t;
 #endif
 
-#if defined(SUPPORTS_VLA)
+ #if defined(SUPPORTS_VLA)
 #  define FLUID_DECLARE_VLA(_type, _name, _len) \
      _type _name[_len]
+#define FLUID_DECLARE_VLA(_type, _name, _len) _type _name[_len]
+#elif defined _MSC_VER
+#define fluid_alloca(size) _alloca((size))
+#define fluid_newa(struct_type, n_structs) \
+    ((struct_type *)fluid_alloca(sizeof(struct_type) * (size_t)(n_structs)))
+#define FLUID_DECLARE_VLA(_type, _name, _len) _type *_name = fluid_newa(_type, (_len))
 #else
 #  define FLUID_DECLARE_VLA(_type, _name, _len) \
      _type* _name = g_newa(_type, (_len))
+/* Should just call alloca() */
+#define FLUID_DECLARE_VLA(_type, _name, _len) _type *_name = g_newa(_type, (_len))
 #endif
 
 
@@ -74,6 +85,10 @@ typedef int fluid_atomic_int_t;
 typedef unsigned int fluid_atomic_uint_t;
 typedef float fluid_atomic_float_t;
 
+#ifndef TRUE
+#define TRUE 1
+#define FALSE 0
+#endif
 
 /***************************************************************
  *
@@ -233,21 +248,11 @@ do { strncpy(_dst,_src,_n-1); \
 #define FLUID_SPRINTF                sprintf
 #define FLUID_FPRINTF                fprintf
 
-#if (defined(WIN32) && _MSC_VER < 1900) || defined(MINGW32)
-/* need to make sure we use a C99 compliant implementation of (v)snprintf(),
- * i.e. not microsofts non compliant extension _snprintf() as it doesn't
- * reliably null-terminate the buffer
- */
-#define FLUID_SNPRINTF           g_snprintf
-#else
+/* Assume a recent enough version of MSVC is used (VS 2015 upwards)
+* so that the following functions are standard compliant */
 #define FLUID_SNPRINTF           snprintf
-#endif
 
-#if (defined(WIN32) && _MSC_VER < 1500) || defined(MINGW32)
-#define FLUID_VSNPRINTF          g_vsnprintf
-#else
 #define FLUID_VSNPRINTF          vsnprintf
-#endif
 
 #if defined(WIN32) && !defined(MINGW32)
 #define FLUID_STRCASECMP         _stricmp
@@ -285,13 +290,20 @@ do { strncpy(_dst,_src,_n-1); \
 #endif
 
 #if defined(DEBUG) && !defined(NDEBUG)
-#define FLUID_ASSERT(a) g_assert(a)
+#include <assert.h>
+#define FLUID_ASSERT(a) assert(a)
 #else
 #define FLUID_ASSERT(a)
 #endif
 
-#define FLUID_LIKELY G_LIKELY
-#define FLUID_UNLIKELY G_UNLIKELY
+#ifdef __GNUC__
+#define FLUID_LIKELY(a) __builtin_expect((a), 1)
+#define FLUID_UNLIKELY(a) __builtin_expect((a), 0)
+#else
+#define FLUID_LIKELY
+#define FLUID_UNLIKELY
+#endif
+
 
 /* Misc */
 #if defined(__INTEL_COMPILER)
