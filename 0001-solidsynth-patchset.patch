diff --git a/src/utils/fluid_atomics.c b/src/utils/fluid_atomics.c
new file mode 100644
index 00000000..7532e45e
--- /dev/null
+++ b/src/utils/fluid_atomics.c
@@ -0,0 +1,303 @@
+/**
+ * MSVC doesn't support C11 atomics (yet)
+ * This whole hack is hopefully provisional
+ */
+
+#ifdef _MSC_VER
+
+#include <stdio.h>
+#include "fluid_atomics.h"
+
+#ifdef _WIN32
+#pragma warning(disable : 4800)
+
+#include <intrin.h>
+
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+
+#ifndef _WIN64
+/* The following is needed for x86 */
+#define _InterlockedIncrement64 InterlockedIncrement64
+#define _InterlockedDecrement64 InterlockedDecrement64
+#define _InterlockedExchangeAdd64 InterlockedExchangeAdd64
+#define _InterlockedOr64 InterlockedOr64
+#define _InterlockedAnd64 InterlockedAnd64
+#define _InterlockedXor64 InterlockedXor64
+#define _InterlockedExchange64 InterlockedExchange64
+#endif
+#endif
+
+int8_t zenny_atomic_fetch_add8(volatile atomic_schar *object, int8_t operand)
+{
+    int8_t expected = *object;
+    int8_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected + operand;
+    } while ((success = zenny_atomic_compare_exchange8(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int16_t zenny_atomic_fetch_add16(volatile atomic_short *object, int16_t operand)
+{
+    int16_t expected = *object;
+    int16_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected + operand;
+    } while ((success = zenny_atomic_compare_exchange16(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int32_t zenny_atomic_fetch_add32(volatile atomic_long *object, int32_t operand)
+{
+    int32_t expected = *object;
+    int32_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected + operand;
+    } while ((success = zenny_atomic_compare_exchange32(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int64_t zenny_atomic_fetch_add64(volatile atomic_llong *object, int64_t operand)
+{
+    int64_t expected = *object;
+    int64_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected + operand;
+    } while ((success = zenny_atomic_compare_exchange64(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int8_t zenny_atomic_fetch_sub8(volatile atomic_schar *object, int8_t operand)
+{
+    int8_t expected = *object;
+    int8_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected - operand;
+    } while ((success = zenny_atomic_compare_exchange8(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int16_t zenny_atomic_fetch_sub16(volatile atomic_short *object, int16_t operand)
+{
+    int16_t expected = *object;
+    int16_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected - operand;
+    } while ((success = zenny_atomic_compare_exchange16(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int32_t zenny_atomic_fetch_sub32(volatile atomic_long *object, int32_t operand)
+{
+    int32_t expected = *object;
+    int32_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected - operand;
+    } while ((success = zenny_atomic_compare_exchange32(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int64_t zenny_atomic_fetch_sub64(volatile atomic_llong *object, int64_t operand)
+{
+    int64_t expected = *object;
+    int64_t desired;
+    bool success;
+
+    do
+    {
+        desired = expected - operand;
+    } while ((success = zenny_atomic_compare_exchange64(object, &expected, desired)),
+             (success ? (void)0 : YieldProcessor()),
+             !success);
+
+    return expected;
+}
+
+int8_t zenny_atomic_fetch_or8(volatile atomic_schar *object, int8_t operand)
+{
+    return _InterlockedOr8(object, operand);
+}
+
+int16_t zenny_atomic_fetch_or16(volatile atomic_short *object, int16_t operand)
+{
+    return _InterlockedOr16(object, operand);
+}
+
+int32_t zenny_atomic_fetch_or32(volatile atomic_long *object, int32_t operand)
+{
+    return _InterlockedOr(object, operand);
+}
+
+int64_t zenny_atomic_fetch_or64(volatile atomic_llong *object, int64_t operand)
+{
+    return _InterlockedOr64(object, operand);
+}
+
+int8_t zenny_atomic_fetch_xor8(volatile atomic_schar *object, int8_t operand)
+{
+    return _InterlockedXor8(object, operand);
+}
+
+int16_t zenny_atomic_fetch_xor16(volatile atomic_short *object, int16_t operand)
+{
+    return _InterlockedXor16(object, operand);
+}
+
+int32_t zenny_atomic_fetch_xor32(volatile atomic_long *object, int32_t operand)
+{
+    return _InterlockedXor(object, operand);
+}
+
+int64_t zenny_atomic_fetch_xor64(volatile atomic_llong *object, int64_t operand)
+{
+    return _InterlockedXor64(object, operand);
+}
+
+int8_t zenny_atomic_fetch_and8(volatile atomic_schar *object, int8_t operand)
+{
+    return _InterlockedAnd8(object, operand);
+}
+
+int16_t zenny_atomic_fetch_and16(volatile atomic_short *object, int16_t operand)
+{
+    return _InterlockedAnd16(object, operand);
+}
+
+int32_t zenny_atomic_fetch_and32(volatile atomic_long *object, int32_t operand)
+{
+    return _InterlockedAnd(object, operand);
+}
+
+int64_t zenny_atomic_fetch_and64(volatile atomic_llong *object, int64_t operand)
+{
+    return _InterlockedAnd64(object, operand);
+}
+
+int8_t zenny_atomic_exchange8(volatile atomic_schar *object, int8_t desired)
+{
+    return _InterlockedExchange8(object, desired);
+}
+
+int16_t zenny_atomic_exchange16(volatile atomic_short *object, int16_t desired)
+{
+    return _InterlockedExchange16(object, desired);
+}
+
+int32_t zenny_atomic_exchange32(volatile atomic_long *object, int32_t desired)
+{
+    return _InterlockedExchange(object, desired);
+}
+
+int64_t zenny_atomic_exchange64(volatile atomic_llong *object, int64_t desired)
+{
+    return _InterlockedExchange64(object, desired);
+}
+
+bool zenny_atomic_compare_exchange8(volatile atomic_schar *object, int8_t *expected, int8_t desired)
+{
+    int8_t comparand = *expected;
+    const int8_t dstValue = _InterlockedCompareExchange8(object, desired, comparand);
+    bool success = dstValue == comparand;
+    if (!success)
+        *expected = dstValue;
+
+    return success;
+}
+
+bool zenny_atomic_compare_exchange16(volatile atomic_short *object, int16_t *expected, int16_t desired)
+{
+    int16_t comparand = *expected;
+    const int16_t dstValue = _InterlockedCompareExchange16(object, desired, comparand);
+    bool success = dstValue == comparand;
+    if (!success)
+        *expected = dstValue;
+
+    return success;
+}
+
+bool zenny_atomic_compare_exchange32(volatile atomic_long *object, int32_t *expected, int32_t desired)
+{
+    int32_t comparand = *expected;
+    int32_t dstValue = _InterlockedCompareExchange(object, desired, comparand);
+    bool success = dstValue == comparand;
+    if (!success)
+        *expected = dstValue;
+
+    return success;
+}
+
+bool zenny_atomic_compare_exchange64(volatile atomic_llong *object, int64_t *expected, int64_t desired)
+{
+    int64_t comparand = *expected;
+    int64_t dstValue = _InterlockedCompareExchange64(object, desired, comparand);
+    bool success = dstValue == comparand;
+    if (!success)
+        *expected = dstValue;
+
+    return success;
+}
+
+bool atomic_flag_test_and_set(volatile atomic_flag *flag)
+{
+    return _InterlockedExchange8((volatile char *)flag, 1) == 1;
+}
+
+bool atomic_flag_test_and_set_explicit(volatile atomic_flag *object, memory_order order)
+{
+    return atomic_flag_test_and_set(object);
+}
+
+void atomic_flag_clear(volatile atomic_flag *flag)
+{
+    _InterlockedExchange8((volatile char *)flag, 0);
+}
+
+void atomic_flag_clear_explicit(volatile atomic_flag *object, memory_order order)
+{
+    atomic_flag_clear(object);
+}
+
+#endif
diff --git a/src/utils/fluid_atomics.h b/src/utils/fluid_atomics.h
new file mode 100644
index 00000000..f7d6aef0
--- /dev/null
+++ b/src/utils/fluid_atomics.h
@@ -0,0 +1,213 @@
+#ifndef _FLUID_ATOMICS_H
+#define _FLUID_ATOMICS_H
+
+/**
+ * Original code from https://github.com/zenny-chen/simple-stdatomic-for-VS-Clang
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(_MSC_VER)
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <uchar.h>
+
+#define ATOMIC_VAR_INIT(value) (value)
+#define atomic_init(object, value) (void)(*(object) = (value))
+
+#ifdef __GNUC__
+#define atomic_store(object, desired) (void)(*(volatile typeof(*(object)) *)(object) = (desired))
+#define atomic_load(object) *(volatile typeof(*(object)) *)(object)
+#else
+#define atomic_store(object, desired) (void)(*(object) = (desired))
+#define atomic_load(object) *(object)
+#endif
+
+#define ATOMIC_FLAG_INIT \
+    {                    \
+        0                \
+    }
+
+typedef enum memory_order
+{
+    memory_order_relaxed,
+    memory_order_consume,
+    memory_order_acquire,
+    memory_order_release,
+    memory_order_acq_rel,
+    memory_order_seq_cst
+} memory_order;
+
+#define atomic_load_explicit(object, order) atomic_load(object)
+#define atomic_store_explicit(object, desired, order) atomic_store((object), (desired))
+
+
+typedef struct atomic_flag
+{
+    bool _Value;
+} atomic_flag;
+
+typedef bool atomic_bool;
+typedef char atomic_char;
+typedef unsigned char atomic_uchar;
+typedef signed char atomic_schar;
+typedef short atomic_short;
+typedef unsigned short atomic_ushort;
+typedef int atomic_int;
+typedef unsigned atomic_uint;
+typedef long atomic_long;
+typedef unsigned long atomic_ulong;
+typedef long long atomic_llong;
+typedef unsigned long long atomic_ullong;
+typedef intptr_t atomic_intptr_t;
+typedef uintptr_t atomic_uintptr_t;
+typedef size_t atomic_size_t;
+typedef ptrdiff_t atomic_ptrdiff_t;
+typedef intmax_t atomic_intmax_t;
+typedef uintmax_t atomic_uintmax_t;
+typedef char16_t atomic_char16_t;
+typedef char32_t atomic_char32_t;
+typedef wchar_t atomic_wchar_t;
+
+
+extern bool atomic_flag_test_and_set(volatile atomic_flag *object);
+extern bool atomic_flag_test_and_set_explicit(volatile atomic_flag *object, memory_order order);
+
+extern void atomic_flag_clear(volatile atomic_flag *object);
+extern void atomic_flag_clear_explicit(volatile atomic_flag *object, memory_order order);
+
+
+#define atomic_fetch_add(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                         \
+     zenny_atomic_fetch_add8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                        \
+      zenny_atomic_fetch_add16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                       \
+       zenny_atomic_fetch_add32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_add64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_add_explicit(object, operand, order) atomic_fetch_add((object), (operand))
+
+extern int8_t zenny_atomic_fetch_add8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_add16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_add32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_add64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_fetch_sub(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                         \
+     zenny_atomic_fetch_sub8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                        \
+      zenny_atomic_fetch_sub16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                       \
+       zenny_atomic_fetch_sub32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_sub64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_sub_explicit(object, operand, order) atomic_fetch_sub((object), (operand))
+
+extern int8_t zenny_atomic_fetch_sub8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_sub16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_sub32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_sub64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_fetch_or(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                        \
+     zenny_atomic_fetch_or8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                       \
+      zenny_atomic_fetch_or16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                      \
+       zenny_atomic_fetch_or32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_or64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_or_explicit(object, operand, order) atomic_fetch_or((object), (operand))
+
+extern int8_t zenny_atomic_fetch_or8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_or16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_or32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_or64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_fetch_xor(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                         \
+     zenny_atomic_fetch_xor8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                        \
+      zenny_atomic_fetch_xor16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                       \
+       zenny_atomic_fetch_xor32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_xor64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_xor_explicit(object, operand, order) atomic_fetch_xor((object), (operand))
+
+extern int8_t zenny_atomic_fetch_xor8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_xor16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_xor32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_xor64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_fetch_and(object, operand)                                               \
+    ((sizeof(*(object)) == 1) ?                                                         \
+     zenny_atomic_fetch_and8((volatile atomic_schar *)(object), (int8_t)(operand)) :    \
+     ((sizeof(*(object)) == 2) ?                                                        \
+      zenny_atomic_fetch_and16((volatile atomic_short *)(object), (int16_t)(operand)) : \
+      ((sizeof(*(object)) == 4) ?                                                       \
+       zenny_atomic_fetch_and32((volatile atomic_long *)(object), (int32_t)(operand)) : \
+       zenny_atomic_fetch_and64((volatile atomic_llong *)(object), (int64_t)(operand)))))
+
+#define atomic_fetch_and_explicit(object, operand, order) atomic_fetch_and((object), (operand))
+
+extern int8_t zenny_atomic_fetch_and8(volatile atomic_schar *object, int8_t operand);
+extern int16_t zenny_atomic_fetch_and16(volatile atomic_short *object, int16_t operand);
+extern int32_t zenny_atomic_fetch_and32(volatile atomic_long *object, int32_t operand);
+extern int64_t zenny_atomic_fetch_and64(volatile atomic_llong *object, int64_t operand);
+
+
+#define atomic_exchange(object, desired)                                               \
+    ((sizeof(*(object)) == 1) ?                                                        \
+     zenny_atomic_exchange8((volatile atomic_schar *)(object), (int8_t)(desired)) :    \
+     ((sizeof(*(object)) == 2) ?                                                       \
+      zenny_atomic_exchange16((volatile atomic_short *)(object), (int16_t)(desired)) : \
+      ((sizeof(*(object)) == 4) ?                                                      \
+       zenny_atomic_exchange32((volatile atomic_long *)(object), (int32_t)(desired)) : \
+       zenny_atomic_exchange64((volatile atomic_llong *)(object), (int64_t)(desired)))))
+
+#define atomic_exchange_explicit(object, desired, order) atomic_exchange((object), (desired))
+
+extern int8_t zenny_atomic_exchange8(volatile atomic_schar *object, int8_t desired);
+extern int16_t zenny_atomic_exchange16(volatile atomic_short *object, int16_t desired);
+extern int32_t zenny_atomic_exchange32(volatile atomic_long *object, int32_t desired);
+extern int64_t zenny_atomic_exchange64(volatile atomic_llong *object, int64_t desired);
+
+
+#define atomic_compare_exchange_strong(object, expected, desired)                                                     \
+    (sizeof(*(object)) == 1 ?                                                                                         \
+     zenny_atomic_compare_exchange8((volatile atomic_schar *)(object), (int8_t *)(expected), (int8_t)(desired)) :     \
+     (sizeof(*(object)) == 2 ?                                                                                        \
+      zenny_atomic_compare_exchange16((volatile atomic_short *)(object), (int16_t *)(expected), (int16_t)(desired)) : \
+      (sizeof(*(object)) == 4 ?                                                                                       \
+       zenny_atomic_compare_exchange32((volatile atomic_long *)(object), (int32_t *)(expected), (int32_t)(desired)) : \
+       zenny_atomic_compare_exchange64((volatile atomic_llong *)(object), (int64_t *)(expected), (int64_t)(desired)))))
+
+#define atomic_compare_exchange_weak atomic_compare_exchange_strong
+
+#define atomic_compare_exchange_strong_explicit(object, expected, desired, success, failure) \
+    atomic_compare_exchange_strong((object), (expected), (desired))
+#define atomic_compare_exchange_weak_explicit(object, expected, desired, success, failure) \
+    atomic_compare_exchange_weak((object), (expected), (desired))
+
+extern bool zenny_atomic_compare_exchange8(volatile atomic_schar *object, int8_t *expected, int8_t desired);
+extern bool zenny_atomic_compare_exchange16(volatile atomic_short *object, int16_t *expected, int16_t desired);
+extern bool zenny_atomic_compare_exchange32(volatile atomic_long *object, int32_t *expected, int32_t desired);
+extern bool zenny_atomic_compare_exchange64(volatile atomic_llong *object, int64_t *expected, int64_t desired);
+
+#endif // #if defined(_MSC_VER)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/utils/fluid_threading.cpp b/src/utils/fluid_threading.cpp
new file mode 100644
index 00000000..82104de9
--- /dev/null
+++ b/src/utils/fluid_threading.cpp
@@ -0,0 +1,157 @@
+#include <cstdio>
+#include <functional>
+#include <chrono>
+#include <thread>
+#include <mutex>
+#include <atomic>
+#include <ratio>
+#include <condition_variable>
+
+#include "fluid_threading.h"
+
+thread_local void *privs[16];
+bool occupied[16] = { false };
+
+void _mutex_init(_mutex *mutex)
+{
+    mutex->mutex = (void *)(new std::mutex);
+}
+
+void _mutex_clear(_mutex *mutex)
+{
+    delete (std::mutex *)(mutex->mutex);
+    mutex->mutex = NULL;
+}
+
+void _mutex_lock(_mutex *mutex)
+{
+    if (!mutex->mutex)
+        mutex->mutex = (void *)(new std::mutex);
+    ((std::mutex *)(mutex->mutex))->lock();
+}
+
+void _mutex_unlock(_mutex *mutex)
+{
+    if (!mutex->mutex)
+        mutex->mutex = (void *)(new std::mutex);
+    ((std::mutex *)(mutex->mutex))->unlock();
+}
+
+void _rec_mutex_init(_rec_mutex *recmutex)
+{
+    recmutex->recmutex = (void *)(new std::recursive_mutex);
+}
+
+void _rec_mutex_clear(_rec_mutex *recmutex)
+{
+    delete (std::recursive_mutex *)(recmutex->recmutex);
+    recmutex->recmutex = NULL;
+}
+
+void _rec_mutex_lock(_rec_mutex *recmutex)
+{
+    if (!recmutex->recmutex)
+        recmutex->recmutex = (void *)(new std::recursive_mutex);
+    ((std::recursive_mutex *)(recmutex->recmutex))->lock();
+}
+
+void _rec_mutex_unlock(_rec_mutex *recmutex)
+{
+    if (!recmutex->recmutex)
+        recmutex->recmutex = (void *)(new std::recursive_mutex);
+    ((std::recursive_mutex *)(recmutex->recmutex))->unlock();
+}
+
+void _cond_init(_cond *cond)
+{
+    cond->cond = (void *)(new std::condition_variable_any);
+}
+
+void _cond_clear(_cond *cond)
+{
+    delete (std::condition_variable_any *)(cond->cond);
+}
+
+void _cond_signal(_cond *cond)
+{
+    ((std::condition_variable_any *)(cond->cond))->notify_one();
+}
+
+void _cond_broadcast(_cond *cond)
+{
+    ((std::condition_variable_any *)(cond->cond))->notify_all();
+}
+
+void _cond_wait(_cond *cond, _mutex *mutex)
+{
+    ((std::condition_variable_any *)(cond->cond))->wait(*(std::mutex *)(mutex->mutex));
+}
+
+void *_private_get(_private *priv)
+{
+    if (!priv->id)
+        for (int i = 0; i < 16; ++i)
+            if (!occupied[i])
+            {
+                priv->id = i + 1;
+                break;
+            }
+    if (priv->id)
+        return privs[priv->id - 1];
+    else
+        return NULL;
+}
+
+void _private_set(_private *priv, void *val)
+{
+    if (!priv->id)
+        for (int i = 0; i < 16; ++i)
+            if (!occupied[i])
+            {
+                priv->id = i + 1;
+                break;
+            }
+    if (priv->id)
+        privs[priv->id - 1] = val;
+}
+
+unsigned _thread_get_id(void)
+{
+    std::hash<std::thread::id> h;
+    return h(std::this_thread::get_id());
+}
+
+void _thread_create(_thread *th, _thread_func_t func, void *data)
+{
+    th->thrd = (void *)(new std::thread(func, data));
+}
+
+void _thread_detach(_thread *th)
+{
+    if (!th->thrd)
+        return;
+    ((std::thread *)(th->thrd))->detach();
+    delete (std::thread *)(th->thrd);
+    th->thrd = nullptr;
+}
+
+void _thread_join(_thread *th)
+{
+    if (!th->thrd)
+        return;
+    ((std::thread *)(th->thrd))->join();
+    delete (std::thread *)(th->thrd);
+    th->thrd = nullptr;
+}
+
+void _thread_sleep(unsigned long us)
+{
+    std::this_thread::sleep_for(std::chrono::microseconds(us));
+}
+
+double _monotonic_time()
+{
+    return std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(
+           std::chrono::steady_clock::now().time_since_epoch())
+    .count();
+}
diff --git a/src/utils/fluid_threading.h b/src/utils/fluid_threading.h
new file mode 100644
index 00000000..5ff498e7
--- /dev/null
+++ b/src/utils/fluid_threading.h
@@ -0,0 +1,65 @@
+#ifndef _FLUID_THREADING_H
+#define _FLUID_THREADING_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void* (*_thread_func_t)(void *data);
+
+typedef struct __mtx
+{
+    void *mutex;
+} _mutex;
+
+typedef struct __recmtx
+{
+    void *recmutex;
+} _rec_mutex;
+
+typedef struct __cnd
+{
+    void *cond;
+} _cond;
+
+typedef struct __prvt
+{
+    int id;
+} _private;
+
+typedef struct __thrd
+{
+    void *thrd;
+} _thread;
+
+void _mutex_init(_mutex *mutex);
+void _mutex_clear(_mutex *mutex);
+void _mutex_lock(_mutex *mutex);
+void _mutex_unlock(_mutex *mutex);
+
+void _rec_mutex_init(_rec_mutex *recmutex);
+void _rec_mutex_clear(_rec_mutex *recmutex);
+void _rec_mutex_lock(_rec_mutex *recmutex);
+void _rec_mutex_unlock(_rec_mutex *recmutex);
+
+void _cond_init(_cond *cond);
+void _cond_clear(_cond *cond);
+void _cond_signal(_cond *cond);
+void _cond_broadcast(_cond *cond);
+void _cond_wait(_cond *cond, _mutex *mutex);
+
+void *_private_get(_private *priv);
+void _private_set(_private *priv, void *val);
+
+unsigned _thread_get_id(void);
+void _thread_create(_thread *th, _thread_func_t func, void *data);
+void _thread_detach(_thread *th);
+void _thread_join(_thread *th);
+void _thread_sleep(unsigned long us);
+double _monotonic_time(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
